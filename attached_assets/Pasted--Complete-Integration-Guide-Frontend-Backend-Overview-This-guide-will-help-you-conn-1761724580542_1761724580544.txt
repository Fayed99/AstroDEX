# Complete Integration Guide - Frontend + Backend

## 🎯 Overview

This guide will help you connect the React frontend with the backend services, smart contracts, and FHEVM SDK.

## 📁 Final Project Structure

```
zama-confidential-dex/
├── contracts/
│   ├── ConfidentialERC20.sol
│   └── ConfidentialDEX.sol
├── scripts/
│   └── deploy.ts
├── test/
│   ├── setup.ts
│   ├── ConfidentialERC20.test.ts
│   └── ConfidentialDEX.test.ts
├── utils/
│   └── fhevmHelper.ts
├── services/
│   └── dexService.ts
├── server/
│   └── api.ts
├── frontend/
│   ├── public/
│   ├── src/
│   │   ├── components/
│   │   │   └── App.tsx          (Main integrated component)
│   │   ├── services/
│   │   │   ├── fhevmService.ts  (Client-side FHEVM)
│   │   │   └── apiService.ts    (API calls)
│   │   ├── config/
│   │   │   └── contracts.ts     (Contract addresses)
│   │   ├── App.tsx
│   │   └── index.tsx
│   ├── package.json
│   └── tsconfig.json
├── hardhat.config.ts
├── package.json
├── tsconfig.json
├── .env
└── deployments.json
```

## 🚀 Step 1: Setup Frontend Project

### 1.1 Create React App with TypeScript

```bash
# In your project root
npx create-react-app frontend --template typescript
cd frontend
```

### 1.2 Install Frontend Dependencies

```bash
npm install fhevmjs ethers@^6.9.0 recharts lucide-react
npm install --save-dev @types/node
```

### 1.3 Update Frontend package.json

Add to `frontend/package.json`:

```json
{
  "proxy": "http://localhost:3001",
  "scripts": {
    "start": "react-app-scripts start",
    "build": "react-app-scripts build",
    "test": "react-app-scripts test"
  }
}
```

## 🔧 Step 2: Create Frontend Services

### 2.1 FHEVM Service (frontend/src/services/fhevmService.ts)

```typescript
import { createInstance, FhevmInstance } from 'fhevmjs';
import { BrowserProvider, Signer } from 'ethers';

class FHEVMService {
  private static instance: FhevmInstance | null = null;
  
  static async init(chainId: number = 8009) {
    if (!this.instance) {
      this.instance = await createInstance({
        chainId,
        networkUrl: 'https://devnet.zama.ai',
        gatewayUrl: 'https://gateway.zama.ai',
      });
    }
    return this.instance;
  }
  
  static async encrypt(
    value: number,
    contractAddress: string,
    userAddress: string
  ): Promise<{ handle: string; proof: string }> {
    if (!this.instance) {
      await this.init();
    }
    
    const input = this.instance!.createEncryptedInput(
      contractAddress,
      userAddress
    );
    input.add64(value);
    const encrypted = await input.encrypt();
    
    return {
      handle: encrypted.handles[0],
      proof: encrypted.inputProof,
    };
  }
  
  static async decrypt(
    encryptedValue: string,
    contractAddress: string,
    provider: BrowserProvider
  ): Promise<number> {
    if (!this.instance) {
      await this.init();
    }
    
    const signer = await provider.getSigner();
    const userAddress = await signer.getAddress();
    
    const decrypted = await this.instance!.decrypt(
      contractAddress,
      encryptedValue
    );
    
    return Number(decrypted);
  }
  
  static getInstance(): FhevmInstance | null {
    return this.instance;
  }
}

export default FHEVMService;
```

### 2.2 API Service (frontend/src/services/apiService.ts)

```typescript
class APIService {
  private static baseURL = process.env.REACT_APP_API_URL || 'http://localhost:3001/api';
  
  private static async call(
    endpoint: string,
    method: string = 'GET',
    data?: any
  ) {
    const options: RequestInit = {
      method,
      headers: {
        'Content-Type': 'application/json',
      },
    };
    
    if (data && method !== 'GET') {
      options.body = JSON.stringify(data);
    }
    
    try {
      const response = await fetch(`${this.baseURL}${endpoint}`, options);
      
      if (!response.ok) {
        throw new Error(`API Error: ${response.statusText}`);
      }
      
      return await response.json();
    } catch (error) {
      console.error('API call failed:', error);
      throw error;
    }
  }
  
  static async swap(
    tokenIn: string,
    tokenOut: string,
    amountIn: number,
    minAmountOut: number
  ) {
    return this.call('/swap', 'POST', {
      tokenIn,
      tokenOut,
      amountIn,
      minAmountOut,
    });
  }
  
  static async createPool(
    tokenA: string,
    tokenB: string,
    amountA: number,
    amountB: number,
    fee: number
  ) {
    return this.call('/pool/create', 'POST', {
      tokenA,
      tokenB,
      amountA,
      amountB,
      fee,
    });
  }
  
  static async addLiquidity(
    tokenA: string,
    tokenB: string,
    amountA: number,
    amountB: number
  ) {
    return this.call('/liquidity/add', 'POST', {
      tokenA,
      tokenB,
      amountA,
      amountB,
    });
  }
  
  static async getBalance(token: string) {
    return this.call(`/balance/${token}`, 'GET');
  }
  
  static async createLimitOrder(
    tokenIn: string,
    tokenOut: string,
    amountIn: number,
    limitPrice: number
  ) {
    return this.call('/order/limit', 'POST', {
      tokenIn,
      tokenOut,
      amountIn,
      limitPrice,
    });
  }
  
  static async getTransactionHistory(address: string) {
    return this.call(`/transactions/${address}`, 'GET');
  }
  
  static async getPoolInfo(tokenA: string, tokenB: string) {
    return this.call(`/pool/${tokenA}/${tokenB}`, 'GET');
  }
}

export default APIService;
```

### 2.3 Contract Config (frontend/src/config/contracts.ts)

```typescript
// This file will be auto-generated after deployment
let deployments: any = null;

// Try to load deployments from backend
async function loadDeployments() {
  try {
    const response = await fetch('/deployments.json');
    deployments = await response.json();
  } catch (error) {
    console.warn('Could not load deployments, using defaults');
    deployments = {
      contracts: {
        dex: '0x0000000000000000000000000000000000000000',
        tokens: {
          WETH: '0x0000000000000000000000000000000000000000',
          USDC: '0x0000000000000000000000000000000000000000',
          DAI: '0x0000000000000000000000000000000000000000',
          WBTC: '0x0000000000000000000000000000000000000000',
        },
      },
    };
  }
}

// Load on module initialization
loadDeployments();

export const CONTRACTS = {
  get DEX_ADDRESS() {
    return deployments?.contracts?.dex || '0x0000000000000000000000000000000000000000';
  },
  get TOKENS() {
    return deployments?.contracts?.tokens || {};
  },
  RPC_URL: process.env.REACT_APP_RPC_URL || 'https://devnet.zama.ai',
  CHAIN_ID: Number(process.env.REACT_APP_CHAIN_ID) || 8009,
  GATEWAY_URL: process.env.REACT_APP_GATEWAY_URL || 'https://gateway.zama.ai',
};

export async function refreshContracts() {
  await loadDeployments();
}
```

## 🔗 Step 3: Connect Frontend to Backend

### 3.1 Update Main App Component

Replace the content of `frontend/src/App.tsx` with the integrated component from the artifact above.

### 3.2 Update Index File (frontend/src/index.tsx)

```typescript
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);

root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

### 3.3 Add Tailwind CSS (frontend/src/index.css)

```css
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}
```

### 3.4 Configure Tailwind (frontend/tailwind.config.js)

```javascript
module.exports = {
  content: [
    "./src/**/*.{js,jsx,ts,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
```

Install Tailwind:

```bash
cd frontend
npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init
```

## 🌐 Step 4: Backend API Enhancements

### 4.1 Add CORS and Better Error Handling (server/api.ts)

Update your server/api.ts:

```typescript
import express from 'express';
import cors from 'cors';
import path from 'path';
import { ethers } from 'ethers';
import { DEXService } from '../services/dexService';

const app = express();

// Middleware
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true,
}));
app.use(express.json());

// Serve deployments.json
app.use('/deployments.json', express.static(path.join(__dirname, '../deployments.json')));

// Request logging
app.use((req, res, next) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
  next();
});

// Global error handler
app.use((err: any, req: express.Request, res: express.Response, next: express.NextFunction) => {
  console.error('Error:', err);
  res.status(500).json({
    success: false,
    error: err.message || 'Internal server error',
  });
});

let dexService: DEXService;

async function initializeServer() {
  try {
    const provider = new ethers.JsonRpcProvider(
      process.env.RPC_URL || 'https://devnet.zama.ai'
    );
    
    const privateKey = process.env.PRIVATE_KEY;
    if (!privateKey) {
      throw new Error('PRIVATE_KEY not set in environment');
    }
    
    const signer = new ethers.Wallet(privateKey, provider);
    
    // Load deployment info
    const fs = require('fs');
    const deploymentPath = path.join(__dirname, '../deployments.json');
    
    if (!fs.existsSync(deploymentPath)) {
      console.warn('⚠️  deployments.json not found. Please run deployment first.');
      console.warn('   Run: npm run deploy');
      return null;
    }
    
    const deployments = JSON.parse(fs.readFileSync(deploymentPath, 'utf-8'));
    
    dexService = new DEXService(
      deployments.contracts.dex,
      deployments.contracts.tokens,
      provider,
      signer
    );
    
    await dexService.initialize();
    console.log('✅ DEX Service initialized');
    
    return dexService;
  } catch (error) {
    console.error('❌ Failed to initialize server:', error);
    throw error;
  }
}

// Health check
app.get('/api/health', (req, res) => {
  res.json({
    success: true,
    status: 'ok',
    timestamp: new Date().toISOString(),
  });
});

// Swap endpoint
app.post('/api/swap', async (req, res, next) => {
  try {
    if (!dexService) {
      return res.status(503).json({
        success: false,
        error: 'Service not initialized',
      });
    }
    
    const { tokenIn, tokenOut, amountIn, minAmountOut } = req.body;
    
    // Validation
    if (!tokenIn || !tokenOut || !amountIn || !minAmountOut) {
      return res.status(400).json({
        success: false,
        error: 'Missing required parameters',
      });
    }
    
    const receipt = await dexService.swap(
      tokenIn,
      tokenOut,
      amountIn,
      minAmountOut
    );
    
    res.json({
      success: true,
      txHash: receipt.hash,
      blockNumber: receipt.blockNumber,
    });
  } catch (error) {
    next(error);
  }
});

// Create pool endpoint
app.post('/api/pool/create', async (req, res, next) => {
  try {
    if (!dexService) {
      return res.status(503).json({
        success: false,
        error: 'Service not initialized',
      });
    }
    
    const { tokenA, tokenB, amountA, amountB, fee } = req.body;
    
    const receipt = await dexService.createPool(
      tokenA,
      tokenB,
      amountA,
      amountB,
      fee
    );
    
    res.json({
      success: true,
      txHash: receipt.hash,
      blockNumber: receipt.blockNumber,
    });
  } catch (error) {
    next(error);
  }
});

// Add liquidity endpoint
app.post('/api/liquidity/add', async (req, res, next) => {
  try {
    if (!dexService) {
      return res.status(503).json({
        success: false,
        error: 'Service not initialized',
      });
    }
    
    const { tokenA, tokenB, amountA, amountB } = req.body;
    
    const receipt = await dexService.addLiquidity(
      tokenA,
      tokenB,
      amountA,
      amountB
    );
    
    res.json({
      success: true,
      txHash: receipt.hash,
      blockNumber: receipt.blockNumber,
    });
  } catch (error) {
    next(error);
  }
});

// Get balance endpoint
app.get('/api/balance/:token', async (req, res, next) => {
  try {
    if (!dexService) {
      return res.status(503).json({
        success: false,
        error: 'Service not initialized',
      });
    }
    
    const { token } = req.params;
    const balance = await dexService.getBalance(token);
    
    res.json({
      success: true,
      balance,
      token,
    });
  } catch (error) {
    next(error);
  }
});

// Create limit order endpoint
app.post('/api/order/limit', async (req, res, next) => {
  try {
    if (!dexService) {
      return res.status(503).json({
        success: false,
        error: 'Service not initialized',
      });
    }
    
    const { tokenIn, tokenOut, amountIn, limitPrice } = req.body;
    
    const receipt = await dexService.createLimitOrder(
      tokenIn,
      tokenOut,
      amountIn,
      limitPrice
    );
    
    res.json({
      success: true,
      txHash: receipt.hash,
      blockNumber: receipt.blockNumber,
    });
  } catch (error) {
    next(error);
  }
});

// Start server
const PORT = process.env.PORT || 3001;

initializeServer().then((service) => {
  if (service) {
    app.listen(PORT, () => {
      console.log(`🚀 API Server running on port ${PORT}`);
      console.log(`📡 Health check: http://localhost:${PORT}/api/health`);
    });
  } else {
    console.error('❌ Server initialization failed');
    process.exit(1);
  }
}).catch((error) => {
  console.error('❌ Fatal error:', error);
  process.exit(1);
});

export default app;
```

## 🚀 Step 5: Complete Deployment

### 5.1 Root .env File

```env
# Backend
PRIVATE_KEY=your_private_key_without_0x
RPC_URL=https://devnet.zama.ai
GATEWAY_URL=https://gateway.zama.ai
PORT=3001
CHAIN_ID=8009

# Frontend (if using .env for frontend)
REACT_APP_API_URL=http://localhost:3001/api
REACT_APP_RPC_URL=https://devnet.zama.ai
REACT_APP_CHAIN_ID=8009
REACT_APP_GATEWAY_URL=https://gateway.zama.ai
```

### 5.2 Deploy Everything

```bash
# 1. Install root dependencies
npm install

# 2. Compile contracts
npm run compile

# 3. Run tests
npm test

# 4. Deploy to testnet
npm run deploy

# 5. Start backend (in one terminal)
npm run server

# 6. Start frontend (in another terminal)
cd frontend
npm start
```

## ✅ Step 6: Verification

### 6.1 Check Backend

```bash
# Test health endpoint
curl http://localhost:3001/api/health

# Expected response:
# {"success":true,"status":"ok","timestamp":"..."}
```

### 6.2 Check Frontend

1. Open http://localhost:3000
2. Click "Connect Wallet"
3. Approve MetaMask connection
4. Try a test swap

### 6.3 Check Integration

Monitor both terminal windows:
- Backend should show API requests
- Frontend should show successful transactions

## 🐛 Troubleshooting

### Issue: "Cannot find deployments.json"
**Solution:**
```bash
npm run deploy
```

### Issue: "MetaMask network mismatch"
**Solution:** Add Zama network to MetaMask:
- Network Name: Zama Devnet
- RPC URL: https://devnet.zama.ai
- Chain ID: 8009
- Currency: ZAMA

### Issue: "FHEVM not initialized"
**Solution:** Check that fhevmjs is properly installed:
```bash
cd frontend
npm install fhevmjs@latest
```

### Issue: "API calls failing"
**Solution:** Check CORS settings in server/api.ts and verify backend is running

## 🎉 Success Checklist

- [ ] Backend compiles without errors
- [ ] Tests pass
- [ ] Contracts deployed successfully
- [ ] Backend server starts
- [ ] Frontend starts
- [ ] Wallet connects
- [ ] Can view encrypted balances
- [ ] Can decrypt balances
- [ ] Can perform swap
- [ ] Can add liquidity
- [ ] Transactions appear in history

## 📖 Next Steps

1. **Security**: Get professional audit
2. **Optimization**: Reduce gas costs
3. **Features**: Add more trading pairs
4. **Monitoring**: Set up error tracking
5. **Testing**: Add more edge cases
6. **Documentation**: Create user guide
7. **Deployment**: Deploy to mainnet when ready

---

**Congratulations!** 🎉 Your Zama Confidential DEX is now fully integrated and ready to use! this it user manual